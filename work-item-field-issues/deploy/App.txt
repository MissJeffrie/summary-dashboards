<!DOCTYPE html>
<html>
<head>
    <title>Work Item Field Issues</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Wed Jan 06 2016 10:10:46 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Jan 06 2016 10:10:46 GMT-0800 (PST)";
        var CHECKSUM = 41283462377;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        
        if (!window.location.origin) {
            window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
        }
        
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});


/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        if ( !Ext.isIE9m ) {
            var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
            var output_args = [];
            output_args = Ext.Array.push(output_args,[timestamp]);
            output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));
    
            window.console && console.log.apply(console,output_args);
        }
    }

});
Ext.define('Rally.technicalservices.ValidationRules',{

    ruleFnPrefix: 'ruleFn_',
    requiredFields: undefined,

    constructor: function(config){
        Ext.apply(this, config);
    },

    getRules: function(){
        var ruleFns = [],
            ruleRe = new RegExp('^' + this.ruleFnPrefix);

        for (var fn in this)
        {
            if (ruleRe.test(fn)){
                ruleFns.push(fn);
            }
        }
        return ruleFns;
    },
    //ruleFn_missingFields: function(r) {
    //    var missingFields = [];
    //
    //    _.each(this.requiredFields, function (f) {
    //        if (!r.get(f)) {
    //            missingFields.push(f);
    //        }
    //    });
    //    if (missingFields.length === 0) {
    //        return null;
    //    }
    //    return Ext.String.format('Missing fields: {0}', missingFields.join(','));
    //},

    statics: {
        getUserFriendlyRuleLabel: function(ruleName){
            switch(ruleName){
                case 'ruleFn_missingFields':
                    return 'Required Fields are missing';
                case 'ruleFn_unscheduledIterationScheduleState':
                    return 'Story is In-Progress with unscheduled Iteration';
                case 'ruleFn_blockedNotInProgress':
                    return 'Story is Blocked but not In-Progress';
                case 'ruleFn_sprintCompleteNotAccepted':
                    return 'Story in past Iteration not complete';
                case 'ruleFn_noStoriesForFeature':
                    return 'Feature has no Stories';
                case 'ruleFn_FeatureHasNotBeenStarted':
                    return 'Feature not started';
                case 'ruleFn_featureHasNotBeenCompleted':
                    return 'Feature not completed.';
                case 'ruleFn_featureMissingFields':
                    return 'Feature fields Missing';
                case 'ruleFn_storyMissingFields':
                    return 'Story fields Missing';
                case 'ruleFn_FeatureHasNoParent':
                    return 'Feature has no parent';
                case 'ruleFn_storyHasNoFeature':
                    return 'Story has no parent Feature';
                case 'ruleFn_storyHasIterationWithoutRelease':
                    return 'Story has Iteration without Release';
                case 'ruleFn_storyBlockedWithoutReason':
                    return 'Story Blocked without Reason';
                case 'ruleFn_storyRelaseDoesNotMatchFeatureRelease':
                    return 'Story Release is not Feature Release';
                case 'ruleFn_storyPlanEstimate':
                    return 'Story has no points';
                case 'ruleFn_storyKanbanState':
                    return 'Story has no Kanban State';
                case 'ruleFn_featureHasNoPoints':
                    return 'Feature has no points';
                case 'ruleFn_storyRiskDescription':
                    return 'Story Risk has no Description';
                case 'ruleFn_featureRiskDescription':
                    return 'Feature Risk has no Description';
                case 'ruleFn_taskMissingFields':
                    return 'Task fields Missing';
                case 'ruleFn_projectMissingWIP':
                    return 'Project Missing WIP';
                case 'ruleFn_iterationMissingFields':
                    return 'Iteration fields Missing';
                case 'ruleFn_FeatureDateIssue':
                    return 'Feature Date Issue';
                case 'ruleFn_isProgramRisk':
                    return 'Feature is program level risk';
            }
            return ruleName;
        }
    }
});
Ext.define('Rally.technicalservices.Validator',{

    validationRuleObj: undefined,
    records: undefined,

    ruleViolationData: undefined,

    constructor: function(config){
        Ext.apply(this,config);
        this._validate();
    },

    _validate: function(){
        if (this.validationRuleObj && this.records){
            var validationRuleObj = this.validationRuleObj,
                ruleViolationRecords = [],
                totalRecords = 0,
                rules = validationRuleObj.getRules();

            _.each(this.records, function(r){
                totalRecords ++;
                var violations = [];
                Ext.Array.each(rules, function(rule){
                    var v = validationRuleObj[rule](r);
                    if (v && !_.isEmpty(v)){
                        violations.push(v);
                        if (v.stopProcessing == true){
                            return false;
                        }
                        //violations.push({rule: rule, text: v});
                    }
                });

                if (violations.length > 0){
                    ruleViolationRecords.push({
                        _ref: r.get('_ref'),
                        FormattedID: r.get('FormattedID'),
                        Name: r.get('Name'),
                        violations: violations,
                        Project: r.get('Project').Name,
                        _type: r.get('_type')
                    });
                }
            });
            this.ruleViolationData = ruleViolationRecords;
        }
    }
});
Ext.define("work-item-field-issues", {
        extend: 'Rally.app.App',
        componentCls: 'app',
        logger: new Rally.technicalservices.Logger(),
        items: [{xtype: 'container', itemId: 'settings_box'}],
        /**
         * Configurations
         * To validate custom fields include them in the Fetch statements below using the c_ form of the attribute name such as c_KanbanState
         */
        allReleasesText: 'All Releases',
        portfolioItemFeature: 'PortfolioItem/Feature',
        featureFetchFields: ['FormattedID','Name','Project','Release','State','AcceptedLeafStoryCount','LeafStoryCount','PlannedStartDate','PlannedEndDate','Owner','ActualStartDate','Parent','ValueScore','LeafStoryPlanEstimateTotal'],
        storyFetchFields: ['FormattedID','Name','Project','Iteration','Release','ScheduleState','Feature','Owner','PlanEstimate','Blocked','BlockedReason','Blocker','c_KanbanState'],
        taskFetchFields: ['FormattedID','Name','Project','Iteration','Release','State','Owner'],


        typeMapping: {
            'portfolioitem/feature': 'Feature',
            'hierarchicalrequirement': 'User Story',
            'task'                   : 'Task'
        },

        chartColors: [ '#2f7ed8', '#8bbc21', '#910000',
            '#492970', '#f28f43', '#145499','#77a1e5', '#c42525', '#a6c96a',
            '#7cb5ec', '#434348', '#90ed7d', '#f7a35c', '#8085e9','#aa1925',
            '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
            '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
            '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

        selectedRelease: null,
        selectedIteration: null,

        launch: function() {

            if (this.isExternal()){
                this.showSettings(this.config);
            } else {
                this.onSettingsUpdate(this.getSettings());
            }
        },

        onTimeboxScopeChange: function(newTimeboxScope) {
            this.logger.log('newTimeboxScope',newTimeboxScope);

            if (((newTimeboxScope) && (newTimeboxScope.get('_type') === 'release'))){
                this.selectedRelease = newTimeboxScope;

            }
            if (((newTimeboxScope) && (newTimeboxScope.get('_type') === 'iteration'))) {
                this.selectedIteration = newTimeboxScope
            }
            this.onTimeboxUpdated(this.selectedRelease, this.selectedIteration);
        },

        getReleaseFilters: function(release){

            if (!release){
                return [];
            }

            return [{
                property: 'Release.Name',
                value: release.get('Name')
            },{
                property: 'Release.ReleaseStartDate',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
            },{
                property: 'Release.ReleaseDate',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
            }];
        },
        
        getIterationFilters: function(iteration){
            if (!iteration){
                return [];
            }
            return [{
                property: 'Iteration.Name',
                value: iteration.get('Name')
            },{
                property: 'Iteration.StartDate',
                value: Rally.util.DateTime.toIsoString(iteration.get('StartDate'))
            },{
                property: 'Iteration.EndDate',
                value: Rally.util.DateTime.toIsoString(iteration.get('EndDate'))
            }];
        },
        
        getIterationFiltersForIterations:function(release){
            if (!release){
                return [];
            }

            return [{
                property: 'StartDate',
                operator: '>=',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
            },{
                property: 'EndDate',
                operator: '<=',
                value: Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
            }];
            
        },
        
        getProjectFilters: function() {
            var project_name = this.getContext().getProject().Name;
            
            return Rally.data.wsapi.Filter.or([
                {property:'Name', value: project_name },
                {property:'Parent.Name', value: project_name }
            ]);
        },
        
        onTimeboxUpdated: function(release, iteration){
            this.logger.log('onTimeboxUpdated',release, iteration);

            if (release == this.selectedRelease && iteration == this.selectedIteration){
                this.getBody().removeAll();

                this.setLoading(true);
                var promises = [
                    this._fetchData(this.portfolioItemFeature, this.featureFetchFields, this.getReleaseFilters(release)),
                    this._fetchData('HierarchicalRequirement', this.storyFetchFields, this.getReleaseFilters(release).concat(this.getIterationFilters(iteration))),
                    this._fetchScheduleStates(),
                //    this._fetchData('Task', this.taskFetchFields, this.getReleaseFilters(release).concat(this.getIterationFilters(iteration))),
                    this._fetchData('Project', ['Name'], this.getProjectFilters()),
                    this._fetchData('Preference',['Name','Value'], [{property:'Name',operator:'contains',value:'project-wip:'}]),
                    this._fetchData('Iteration',['Name','PlannedVelocity','Project'], this.getIterationFiltersForIterations(release))
                ];

                Deft.Promise.all(promises).then({
                    scope: this,
                    success: function(records){
                        this.setLoading(false);
                        this.logger.log('_fetchData success', records);

                        var features        = records[0];
                        var stories         = records[1];
                        var schedule_states = records[2];
                       // var tasks           = records[3];
                        var projects        = records[3];
                        var project_preferences = records[4];
                        var iterations      = records[5];

                        var featureRules = Ext.create('Rally.technicalservices.FeatureValidationRules',{
                                stories: stories
                            }),
                            featureValidator = Ext.create('Rally.technicalservices.Validator',{
                                validationRuleObj: featureRules,
                                records: features
                            });

                        var storyRules = Ext.create('Rally.technicalservices.UserStoryValidationRules',{
                                features: features,
                                orderedScheduleStates: schedule_states,
                                definedScheduleStateIndex: _.indexOf(schedule_states, 'Defined')
                            }),
                            storyValidator = Ext.create('Rally.technicalservices.Validator',{
                                validationRuleObj: storyRules,
                                records: stories
                            });

                        //var taskRules = Ext.create('Rally.technicalservices.TaskValidationRules',{ }),
                        //    taskValidator = Ext.create('Rally.technicalservices.Validator',{
                        //        validationRuleObj: taskRules,
                        //        records: tasks
                        //    });
                       
                       var projectRules = Ext.create('Rally.technicalservices.ProjectValidationRules',{
                                projectPrefs: project_preferences
                            }),
                            projectValidator = Ext.create('Rally.technicalservices.Validator',{
                                validationRuleObj: projectRules,
                                records: projects
                            });
                            
                       var iterationRules = Ext.create('Rally.technicalservices.IterationValidationRules',{ }),
                            iterationValidator = Ext.create('Rally.technicalservices.Validator',{
                                validationRuleObj: iterationRules,
                                records: iterations
                            });
                            
                        this.validatorData = featureValidator.ruleViolationData
                            .concat(    storyValidator.ruleViolationData)
                        //    .concat(     taskValidator.ruleViolationData)
                            .concat(  projectValidator.ruleViolationData)
                            .concat(iterationValidator.ruleViolationData);
                            
                        this._createSummaryHeader(this.validatorData);

                    },
                    failure: function(operation){
                        this.setLoading(false);
                        this.logger.log('_fetchData failure', operation);
                    }
                });

            }
        },
        _fetchScheduleStates: function(){
            var deferred = Ext.create('Deft.Deferred');
            var scheduleStates = [];
            Rally.data.ModelFactory.getModel({
                type: 'UserStory',
                fetch: ['ValueIndex','StringValue'],
                sorters: [{
                    property: 'ValueIndex',
                    direction: 'ASC'
                }],
                success: function(model) {
                    model.getField('ScheduleState').getAllowedValueStore().load({
                        callback: function(records, operation, success) {
                            Ext.Array.each(records, function(allowedValue) {
                                //each record is an instance of the AllowedAttributeValue model
                                scheduleStates.push(allowedValue.get('StringValue'));
                            });
                            deferred.resolve(scheduleStates);
                        }
                    });
                }
            });

            return deferred;
        },
        _createSummaryHeader: function(validatorData){

            var ct_chart = this.down('#ct-chart');
            if (!ct_chart){
                var ct_chart = this.getBody().add({
                    itemId: 'ct-chart',
                    xtype: 'container',
                    flex: 1
                });
            }
            this._createSummaryChart(ct_chart, validatorData);

            var ct_detail_grid = this.down('#ct-grid');
            if (!ct_detail_grid){
                var ct_detail_grid = this.getBody().add({
                    xtype: 'container',
                    itemId: 'ct-grid'
                });
            }
            this._createDetailGrid(ct_detail_grid, validatorData);

        },
        _createSummaryChart: function(ct,validatorData){

            var dataHash = {}, projects = [], types = [], rules = [];

            _.each(validatorData, function(obj){
                if (!_.contains(projects,obj.Project)){
                    projects.push(obj.Project);
                }
                if (!_.contains(types, obj._type)){
                    types.push(obj._type);
                }
                if (!dataHash[obj.Project]){
                    dataHash[obj.Project] = {};
                }
                if (!dataHash[obj.Project][obj._type]){
                    dataHash[obj.Project][obj._type] = {};
                }
                _.each(obj.violations, function(v){
                    if (!_.contains(rules, v.rule)){
                        rules.push(v.rule);
                    }
                    dataHash[obj.Project][obj._type][v.rule] = (dataHash[obj.Project][obj._type][v.rule] || 0) + 1;
                });
            });

            projects.sort();

            var series = [];

            var stack_by_type = {
                'project': 'project',
                'iteration': 'project',
                'portfolioitem/feature': 'feature',
                'hierarchicalrequirement': 'story',
                'task': 'story' // want to stack stories and tasks together
            };
            
            _.each(types, function(t){
                _.each(rules, function(r){
                    var data = [];
                    _.each(projects, function(p){
                        if (dataHash[p] && dataHash[p][t]){
                            data.push(dataHash[p][t][r] || 0);
                        } else {
                            data.push(0);
                        }
                    });
                    series.push({
                        name: Rally.technicalservices.ValidationRules.getUserFriendlyRuleLabel(r),
                        data: data,
                        stack: stack_by_type[t],
                        showInLegend: Ext.Array.sum(data) > 0
                    });
                });
            });

            var categories = Ext.Array.map(projects, function(project) { return _.last(project.split('>')); });
            
            var subtitle_text = (this.selectedRelease ? 'Release <b>' + this.selectedRelease.get('Name')  + '</b>': 'All Releases') +
                ', ' +
                (this.selectedIteration ? 'Iteration <b>' + this.selectedIteration.get('Name') + '</b>' : 'All Iterations');

            if (this.down('#summary-chart')){
                this.down('#summary-chart').destroy();
            }
            var chart = ct.add({
                xtype: 'rallychart',
                itemId: 'summary-chart',
                loadMask: false,
                chartData: {
                    series: series,
                    categories: categories
                },
                chartConfig: {
                    chart: {
                        type: 'column'
                    },
                    title: {
                        text: 'Work Item Field Issues'
                    },
                    subtitle: {
                        text: subtitle_text
                    },
                    legend: {
                        align: 'center',
                        verticalAlign: 'bottom'
                    },
                    xAxis: {
                        categories: projects
                    },
                    yAxis: {
                        title: 'Project'
                    },
                    plotOptions: {
                        column: {
                           stacking: 'normal'
                            }
                        }
                    }
                });
            ct.setSize(chart.getWidth(), chart.getHeight());
        },
        _createDetailGrid: function(ct, violationData){

            ct.removeAll();

            var store = Ext.create('Rally.data.custom.Store',{
                data: violationData,
                pageSize: violationData.length,
                groupField: 'Project',
                groupDir: 'ASC',
                remoteSort: false,
                getGroupString: function(record) {
                    return record.get('Project');
                }
            });

            if (this.down('#detail-grid')){
                this.down('#detail-grid').destroy();
            }

            ct.add({
                xtype:'rallygrid',
                store: store,
                itemId: 'detail-grid',
                columnCfgs: this._getColumnCfgs(),
                showPagingToolbar: false,
                features: [{
                    ftype: 'groupingsummary',
                    groupHeaderTpl: '{name} ({rows.length})',
                    startCollapsed: true
                }]

            });

        },
        _getColumnCfgs: function(){
            return [{
                dataIndex: 'FormattedID',
                text: 'FormattedID',
                renderer: this._artifactRenderer
            },{
                dataIndex: 'violations',
                text:'Issues',
                renderer: this._validatorRenderer,
                flex: 1
            }];
        },
        _artifactRenderer: function(v,m,r){
            if ( r.get('_type') == 'iteration' ) {
                return r.get('Name');
            }
            return Rally.nav.DetailLink.getLink({
                record: r,
                text: v
            });
            return v;
        },
        _validatorRenderer: function(v,m,r){
            var issues = '';
            if (v && v.length > 0){
                _.each(v, function(va){
                    issues += va.text + '<br/>';
                });
            }
            return issues;
        },
        _fetchData: function(modelType, fetchFields, filters){

            var deferred = Ext.create('Deft.Deferred'),
                store = Ext.create('Rally.data.wsapi.Store',{
                    model: modelType,
                    limit: 'Infinity',
                    fetch: fetchFields,
                    filters: filters
                });

            store.load({
                scope: this,
                callback: function(records, operation, success){
                    if (success){
                        deferred.resolve(records);
                    } else {
                        deferred.reject(operation);
                    }
                }
            });
            return deferred;
        },
        getHeader: function(){
            this.logger.log('getHeader');

            if (this.down('#ct-header')){
                return this.down('#ct-header');
            }

            return this.add({
                xtype: 'container',
                itemId: 'ct-header'
                //layout: {type: 'hbox'}
            });
        },

        getBody: function(){
            this.logger.log('getBody');

            if (this.down('#ct-body')){
                return this.down('#ct-body');
            }
            return this.add({
                xtype: 'container',
                itemId: 'ct-body'
            });
        },
    /********************************************
     /* Overrides for App class
     /*
     /********************************************/
    getSettingsFields: function() {
        return [
            {
                name: 'showScopeSelector',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 25 200',
                boxLabel: 'Show Scope Selector<br/><span style="color:#999999;"><i>Tick to use this to broadcast settings.</i></span>'
            }];
    },
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },

    showSettings: function(options) {
        this._appSettings = Ext.create('Rally.app.AppSettings', Ext.apply({
            fields: this.getSettingsFields(),
            settings: this.getSettings(),
            defaultSettings: this.getDefaultSettings(),
            context: this.getContext(),
            settingsScope: this.settingsScope,
            autoScroll: true
        }, options));

        this._appSettings.on('cancel', this._hideSettings, this);
        this._appSettings.on('save', this._onSettingsSaved, this);
        if (this.isExternal()){
            if (this.down('#settings_box').getComponent(this._appSettings.id)==undefined){
                this.down('#settings_box').add(this._appSettings);
            }
        } else {
            this.hide();
            this.up().add(this._appSettings);
        }
        return this._appSettings;
    },
    _onSettingsSaved: function(settings){
        Ext.apply(this.settings, settings);
        this._hideSettings();
        this.onSettingsUpdate(settings);
    },

    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);

        var release = null, iteration = null;

        if ( this.getSetting('showScopeSelector') || this.getSetting('showScopeSelector') == "true" ) {
            var tb = this.getHeader().add({
                xtype : 'timebox-selector',
                context : this.getContext()
            });
            tb.on('releasechange', this.onTimeboxScopeChange, this);
            tb.on('iterationchange', this.onTimeboxScopeChange, this);
            release = tb.getReleaseRecord();
            iteration = tb.getIterationRecord();
          //  this.onTimeboxScopeChange(release, iteration);
        } else {
            //this.onTimeboxScopeChange(release, iteration);
            this.subscribe(this, 'timeboxReleaseChanged', this.onTimeboxScopeChange, this);
            this.subscribe(this, 'timeboxIterationChanged', this.onTimeboxScopeChange, this);
            this.publish('requestTimebox', this);
        }
    }
});

Ext.define('Rally.technicalservices.FeatureValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',

    requiredFields: undefined,
    stories: undefined,

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Owner','State'];

    },
    /**
     **  For an example of custom field validation see story-validation.js
     **/
    ruleFn_noStoriesForFeature: function(r){

        if (r.get('LeafStoryCount') == 0) {
            return {
                rule: 'ruleFn_noStoriesForFeature',
                text: Ext.String.format('<li>Feature has no stories.')
            };
        }
        return null;
    },
    ruleFn_featureHasNoPoints: function(r){
        if (r.get('LeafStoryCount') > 0 && r.get('LeafStoryPlanEstimateTotal')==0){
            return {
                rule: 'ruleFn_featureHasNoPoints',
                text: '<li>Feature has no points.'
            }
        }
        return null;
    },
    ruleFn_FeatureDateIssue: function(r){

        //if (this.ruleFn_isProgramRisk(r) == null) {
            var planned_start = r.get('PlannedStartDate');

            if (!r.get('ActualStartDate')){
                if (planned_start) {
                    if (Rally.util.DateTime.fromIsoString(planned_start) <= new Date()){
                        return {
                            rule: 'ruleFn_FeatureDateIssue',
                            text: Ext.String.format('<li>Feature Date Issue:  Feature not started when planned')
                        };
                    }
                } else {
                    return {
                        rule: 'ruleFn_FeatureDateIssue',
                        text: Ext.String.format('<li>Feature Date Issue:  Feature has no PlannedStartDate')
                    };
                }
            }

            var planned_end = r.get('PlannedEndDate');

            if (!r.get('ActualEndDate')){
                if (planned_end) {
                    if (Rally.util.DateTime.fromIsoString(planned_end) <= new Date()){
                        return {
                            rule: 'ruleFn_FeatureDateIssue',
                            text: Ext.String.format('<li>Feature Date Issue:  Feature was not completed on its planned end date.')
                        };
                    }
                } else {
                    return {
                        rule: 'ruleFn_FeatureDateIssue',
                        text: Ext.String.format('<li>Feature Date Issue:  Feature has no PlannedEndDate')
                    };
                }
            }
        //}
        return null;
    },
    //ruleFn_FeatureHasNotBeenStarted: function(r){
    //    if (!r.get('ActualStartDate')){
    //        return Ext.String.format('<li>Feature has not started.');
    //    }
    //    return null;
    //},
    //ruleFn_featureHasNotBeenCompleted: function(r){
    //    if (!r.get('ActualEndDate')){
    //        return Ext.String.format('<li>Feature not completed.');
    //    }
    //    return null;
    //},
    ruleFn_featureMissingFields: function(r) {
        // if (this.ruleFn_isProgramRisk(r) == null) {
            var missingFields = [];

            _.each(this.requiredFields, function (f) {
                if (!r.get(f)) {
                    var name = r.getField(f) ? r.getField(f).displayName : f;
                    missingFields.push(name);
                }
            });
            if (missingFields.length === 0) {
                return null;
            }
            return {
                rule: 'ruleFn_featureMissingFields',
                text: Ext.String.format('<li>Feature fields Missing: {0}', missingFields.join(','))
            };
        // }
        return null;
    },
    ruleFn_FeatureHasNoParent: function(r) {
        if (!r.get('Parent')) {
            return {
                rule: 'ruleFn_FeatureHasNoParent',
                text: Ext.String.format('<li>Feature has no parent.')
            };
        }
        return null;
    }
});

Ext.define('Rally.technicalservices.IterationValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',
    //ruleFnPrefix: 'ruleFn_',
    requiredFields: ['PlannedVelocity'], //
    /**
     * 
     * @config {Ext.data.Model}  
     * 
     * An array of the preferences where the names contain 'project-wip'
     */
    projectPrefs: [],
    
    constructor: function(config){
        Ext.apply(this, config);
    },
    ruleFn_iterationMissingFields: function(r) {
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f) && r.getField(f)) {
                var name = r.getField(f).displayName;
                missingFields.push(name);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return {
            rule: 'ruleFn_iterationMissingFields',
            text: Ext.String.format('<li>Iteration fields Missing: {0}', missingFields.join(','))
        };
    }
});


Ext.define('Rally.technicalservices.ProjectValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',
    //ruleFnPrefix: 'ruleFn_',
    requiredFields: ['Owner'], //
    /**
     * 
     * @config {Ext.data.Model}  
     * 
     * An array of the preferences where the names contain 'project-wip'
     */
    projectPrefs: [],
    
    constructor: function(config){
        Ext.apply(this, config);
    },
    ruleFn_projectMissingWIP: function(r) {
        // set the project to itself so that we can use it in the chart
        r.set('Project',r.getData());
        
        var missingWIPTypes = [];
        var checkWIPTypes = ["Completed","Defined","In-Progress"];
        
        var prefs = this._getPrefForProject(r.get('Name'));

        Ext.Array.each(checkWIPTypes, function(checkType){
            if ( !prefs[checkType] || prefs[checkType] === "" || prefs[checkType] == "0" ) {
                missingWIPTypes.push(checkType);
            }
        });
        
        if (missingWIPTypes.length === 0) {
            return null;
        }
        return {
            rule: 'ruleFn_projectMissingWIP',
            text: Ext.String.format('<li>Project Missing WIP: {0}', missingWIPTypes.join(','))
        };
    },
    
    _getPrefForProject: function(project_name) {
        var prefs = {};
        var projectRegex = new RegExp(project_name);
        Ext.Array.each(this.projectPrefs, function(pref){
            var key = pref.get('Name');
            // project-wip:IA-Program > OR Solution Architecture Team:CompletedWIP
            //"project-wip:" + projectname + ":" + state + "WIP";
            if ( projectRegex.test(key) ) {
                var type = _.last(key.split(':')).replace(/WIP.*$/,'');
                prefs[type] = Ext.JSON.decode(pref.get('Value'));
            }
        });
        return prefs;
    }
});


Ext.define('Rally.technicalservices.UserStoryValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',
    //ruleFnPrefix: 'ruleFn_',
    requiredFields: undefined, //
    features: undefined,
    orderedScheduleStates: undefined,
    definedScheduleStateIndex: undefined,

    constructor: function(config){
        Ext.apply(this, config);
        this.requiredFields = ['Owner','PlanEstimate'];
    },
    ruleFn_unscheduledIterationScheduleState: function(r){
        /**
         * If Iteration = unscheduled and state In-Progress raise flag
         */
        var scheduleStateIdx = _.indexOf(this.orderedScheduleStates, r.get('ScheduleState'));

        if (!r.get('Iteration') && scheduleStateIdx > this.definedScheduleStateIndex){
            return {
                rule: 'ruleFn_unscheduledIterationScheduleState',
                text: Ext.String.format('<li>Story is In-Progress with unscheduled Iteration', r.get('ScheduleState'))
            };
        }
        return null;
    },
//    ruleFn_blockedNotInProgress: function(r){
//        /**
//         * Story is blocked, schedulestate must be In-Progress
//         */
//        if (r.get('Blocked')){
//            if (r.get('ScheduleState') != 'In-Progress'){
//                return Ext.String.format('<li>Story is Blocked but not In-Progress ({0})', r.get('ScheduleState'));
//            }
//        }
//        return null;
//    },
    ruleFn_storyMissingFields: function(r) {
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f) && r.getField(f)) {
                var name = r.getField(f).displayName;
                missingFields.push(name);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return {
            rule: 'ruleFn_storyMissingFields',
            text: Ext.String.format('<li>Story fields Missing: {0}', missingFields.join(','))
        };
    },
    ruleFn_storyHasNoFeature: function(r){
        if (!r.get('Feature')){
            return {
                rule: 'ruleFn_storyHasNoFeature',
                text: '<li>Story has no parent Feature.'
            };
        }
        return null;
    },
    ruleFn_storyPlanEstimate: function(r){
        if (r.get('PlanEstimate')==0){
            return {
                rule: 'ruleFn_storyPlanEstimate',
                text: '<li>Story has no points'
            };
        }
        return null;
    },
    ruleFn_storyHasIterationWithoutRelease: function(r){
        if (!r.get('Release') && r.get('Iteration')){
            return {
                rule: 'ruleFn_storyHasIterationWithoutRelease',
                text: Ext.String.format('<li>Story has Iteration [{0}] without a Release.', r.get('Iteration').Name)
            };
        }
        return null;
    },
    ruleFn_storyBlockedWithoutReason: function(r){
        if (r.get('Blocked') && !r.get('BlockedReason')){
            return {
                rule: 'ruleFn_storyBlockedWithoutReason',
                text: '<li>Story is blocked without reason.'
            };
            //if (r.get('Blocker')){
            //    return '<li>Story is blocked without reason.';
            //} else {
            //    return '<li>Story is blocked without a reason.';
            //}
        }
        return null;
    },
    ruleFn_storyRelaseDoesNotMatchFeatureRelease: function(r){
        var msg = null;

        var release = r.get('Release');
        if (r.get('Feature') && release){

            if (!r.get('Feature').Release || r.get('Feature').Release.Name != release.Name ||
                r.get('Feature').Release.ReleaseStartDate != release.ReleaseStartDate ||
                r.get('Feature').Release.ReleaseDate != release.ReleaseDate){
                return {
                    rule: 'ruleFn_storyRelaseDoesNotMatchFeatureRelease',
                    text: '<li>Story Release is not Feature Release'
                };
            }
        }
        return msg;
    },
    /**
     ** Below is an example of validation on the custom field c_KanbanState
     **/
    ruleFn_storyKanbanState: function(r){
        console.log('storyKanbanState',r)
        if (!r.get('c_KanbanState')){
            return {
                rule: 'ruleFn_storyKanbanState',
                text: '<li>Story Kanban State has no value'
            };
        }
        return null;
    }
});


Ext.define('Rally.technicalservices.TaskValidationRules',{
    extend: 'Rally.technicalservices.ValidationRules',
    //ruleFnPrefix: 'ruleFn_',
    requiredFields: ['Owner'], //

    constructor: function(config){
        Ext.apply(this, config);
    },
    ruleFn_taskMissingFields: function(r) {
        // force FormattedID so it shows in the left column
        r.set('FormattedID', r.get('Name'));
        var missingFields = [];

        _.each(this.requiredFields, function (f) {
            if (!r.get(f) && r.getField(f)) {
                var name = r.getField(f).displayName;
                missingFields.push(name);
            }
        });
        if (missingFields.length === 0) {
            return null;
        }
        return Ext.String.format('<li>Task fields Missing: {0}', missingFields.join(','));
    }
});


Ext.define('timebox-selector', {
    extend : 'Ext.Container',
    componentCls : 'app',
    alias : 'widget.timebox-selector',
    cls : 'timebox-selector',
    layout : 'hbox',
    width : '100%',
    mixins : [
        'Rally.Messageable'
    ],
    constructor : function()
    {
        this.stateId = Rally.environment.getContext().getScopedStateId('timebox-filter');
        this.callParent(arguments);
    },
    initComponent : function()
    {
        this.callParent(arguments);
        this._createReleaseCombo();
        this.addEvents('releasechange','iterationchange');
        
        // configured to allow others to ask what the current selection is,
        // in case they missed the initial message
        this.subscribe(this, 'requestTimebox', this._requestTimebox, this);
        
    },
    _createReleaseCombo : function()
    {
        this._releaseCombo = this.add({
            xtype : 'rallyreleasecombobox',
            fieldLabel : 'Program Increment',
            hideLabel : false,
            labelPad : 5,
            labelSeparator : ':',
            labelWidth : 130,
            width : 280,
            labelAlign : 'right',
            stateful : false,
            stateId : 'releasecombo',
            padding : 5,
            context : Rally.environment.getContext(),
            showArrows : false,
            growToLongestValue : true,
            defaultToCurrentTimebox : true,
            listeners : {
                change : function(t, newVal, oldVal, eOpts)
                {
                    var release = t.getRecord();
                    this.fireEvent('releasechange',release);

                    this.publish('timeboxReleaseChanged', release);
                    this._updateIterationCombo(release);
                },
                scope : this
            }
        });
    },
    _updateIterationCombo : function(release)
    {
        this.remove('globaliterationpicker');
        this.fireEvent('iterationchange',null);
        this.publish('timeboxIterationChanged', null);
                    
        var endFilter = Ext.create('Rally.data.wsapi.Filter', {
            property : "EndDate",
            operator : "<=",
            value : Rally.util.DateTime.toIsoString(release.get('ReleaseDate'))
        });
        var startFilter = Ext.create('Rally.data.wsapi.Filter', {
            property : "StartDate",
            operator : ">=",
            value : Rally.util.DateTime.toIsoString(release.get('ReleaseStartDate'))
        });
        var filters = endFilter.and(startFilter);

        this._iterationCombo = this.add({
            xtype : 'rallyiterationcombobox',
            itemId : 'globaliterationpicker',
            fieldLabel : 'Sprint/Iteration',
            hideLabel : false,
            labelPad : 5,
            labelSeparator : ':',
            labelWidth : 100,
            labelAlign : 'right',
            stateful : false,
            padding : 5,
            context : Rally.environment.getContext(),
            showArrows : false,
            growToLongestValue : true,
            stateId : 'iterationcombo',
            allowBlank : true,
            allowClear : true,
            allowNoEntry : true,
            noEntryText : 'PI Scope',
            emptyText : 'PI Scope',
            noEntryValue : null,
            defaultToCurrentTimebox : false,
            defaultSelectPosition : 'first',
            storeConfig : {
                remoteFilter : true,
                filters : filters
            },
            listeners : {
                change : function(t, newVal, oldVal, eOpts)
                {
                    var iteration = t.getRecord();
                    this.fireEvent('iterationchange',iteration);
                    this.publish('timeboxIterationChanged', iteration);
                },
                scope : this
            }
        });
    },
    _requestTimebox : function(source) {
         var release = this.getReleaseRecord();
        if (release) {
            this.publish('timeboxReleaseChanged', release);
        } 
        
        var iteration = this.getIterationRecord();
        if (iteration) {
            this.publish("timeboxIterationChanged",  iteration);
        }
    },
    getReleaseRecord: function(){
        if (this._releaseCombo){
            return this._releaseCombo.getRecord() || null;
        }
        return null;
    },
    getIterationRecord: function(){
        if (this._iterationCombo){
            return this._iterationCombo.getRecord() || null;
        }
        return null;
    }
});
            
               Rally.launchApp('work-item-field-issues', {
                   name: 'Work Item Field Issues'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

    </style>

</head>
<body></body>
</html>